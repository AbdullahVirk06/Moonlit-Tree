<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clustered Moonlit Forest</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Deep Night Sky to Twilight Purple Horizon */
            background: linear-gradient(to bottom, #090518 0%, #1a0b2e 60%, #3e1e45 100%);
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            text-align: center;
            font-size: 18px;
            text-shadow: 0 0 10px #FF1493;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="instructions">Click to Grow Forest</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let objects = []; 
        let bgObjects = [];
        let stars = [];

        // --- Configuration ---
        const config = {
            branchColor: '#4E342E',
            flowerColor: '#FF1493',   
            centerColor: '#FFD700',   
            grassColor: '#00e676',    
            
            growSpeed: 7,           
            flowerBloomSpeed: 1,    
            
            maxDepth: 7,            
            flowerSize: 8,          
            
            gravity: 1.0,           
            wind: 1.0
        };

        // --- Background: Stars & Moon ---
        function createStars() {
            stars = [];
            for (let i = 0; i < 150; i++) { 
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.8, 
                    size: Math.random() * 1.5,
                    opacity: Math.random(),
                    pulseSpeed: 0.005 + Math.random() * 0.01 
                });
            }
        }

        function drawBackground() {
            ctx.shadowBlur = 0; 
            stars.forEach(star => {
                star.opacity += star.pulseSpeed;
                if(star.opacity > 1 || star.opacity < 0.2) star.pulseSpeed *= -1;
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(star.opacity)})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.save();
            ctx.shadowBlur = 40;
            ctx.shadowColor = "white";
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(width * 0.8, height * 0.2, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            createStars();
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Grass Class (Slow) ---
        class Grass {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetHeight = Math.random() * 30 + 10; 
                this.height = 0; 
                this.angle = (Math.random() - 0.5) * 0.5; 
            }
            update() {
                if (this.height < this.targetHeight) this.height += 0.5; 
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.strokeStyle = config.grassColor;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 5; 
                ctx.shadowColor = config.grassColor;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(5, -this.height / 2, 0, -this.height);
                ctx.stroke();
                ctx.restore();
            }
        }

        // --- Flower Class (Fast) ---
        class Flower {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.finalSize = Math.random() * 3 + config.flowerSize;
                this.currentSize = 0;
                this.state = 'growing'; 
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.2; 
                this.vy = 0;
            }

            update() {
                if (this.state === 'growing') {
                    this.currentSize += config.flowerBloomSpeed;
                    if (this.currentSize >= this.finalSize) {
                        this.currentSize = this.finalSize;
                        this.state = 'attached';
                    }
                } 
                else if (this.state === 'attached') {
                    if (Math.random() < 0.02) this.state = 'falling';
                } 
                else if (this.state === 'falling') {
                    this.vy += 0.08; 
                    this.y += this.vy + config.gravity;
                    this.x += Math.sin(Date.now() * 0.01) * config.wind; 
                    this.rotation += this.rotSpeed;
                    if (this.y > height) { this.y = height; this.vy = 0; this.rotSpeed = 0; }
                }
            }

            draw(ctx) {
                if (this.currentSize <= 0) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = config.flowerColor;
                ctx.fillStyle = config.flowerColor;
                
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.ellipse(0, this.currentSize, this.currentSize / 2.5, this.currentSize, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.rotate(Math.PI * 2 / 5);
                }
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = config.centerColor;
                ctx.beginPath();
                ctx.arc(0, 0, this.currentSize / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // --- Branch Class (Fast) ---
        class Branch {
            constructor(x, y, angle, depth) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.depth = depth;
                this.len = 0;
                this.maxLen = (Math.random() * 20) + (depth * 10);
                this.finished = false;
                this.branches = [];
                this.flowers = [];
            }

            update() {
                if (this.len < this.maxLen) {
                    this.len += config.growSpeed;
                } else if (!this.finished) {
                    this.finished = true;
                    let endX = this.x + Math.cos(this.angle) * this.len;
                    let endY = this.y + Math.sin(this.angle) * this.len;

                    if (this.depth > 0) {
                        let num = 2;
                        for (let i = 0; i < num; i++) {
                            let dir = (i === 0) ? 1 : -1;
                            let newAngle = this.angle + (Math.random() * 0.5 + 0.3) * dir;
                            this.branches.push(new Branch(endX, endY, newAngle, this.depth - 1));
                        }
                    }
                    if (this.depth < 4 && this.depth > 0) { 
                        this.flowers.push(new Flower(endX, endY));
                    }
                }
                this.branches.forEach(b => b.update());
                this.flowers.forEach(f => f.update());
            }

            draw(ctx) {
                let endX = this.x + Math.cos(this.angle) * this.len;
                let endY = this.y + Math.sin(this.angle) * this.len;
                
                ctx.strokeStyle = config.branchColor;
                ctx.lineWidth = this.depth + 1;
                ctx.lineCap = "round";
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                this.branches.forEach(b => b.draw(ctx));
                this.flowers.forEach(f => f.draw(ctx));
            }
        }

        // --- Manager ---
        function startGarden() {
            objects = [];
            bgObjects = [];
            const instr = document.getElementById('instructions');
            if(instr) instr.style.opacity = 0;

            let rootX = width / 2;
            let rootY = height - 50; 

            // 1. Create Background Trees (CLUSTERED CLOSE TO CENTER)
            // We create 6 trees that are bunched within Â±300px of the center
            for(let i=0; i<6; i++) {
                // SPREAD: Reduced from 'width' to just 600px total area around root
                let bgX = rootX + (Math.random() - 0.5) * 600; 
                let bgY = rootY - Math.random() * 50; 
                // Smaller size (maxDepth - 3)
                bgObjects.push(new Branch(bgX, bgY, -Math.PI/2, config.maxDepth - 3));
            }
            
            // 2. Create Main Foreground Tree
            objects.push(new Branch(rootX, rootY, -Math.PI / 2, config.maxDepth));

            // 3. Create Grass
            for(let i=0; i<40; i++) { 
                let offsetX = (Math.random() - 0.5) * 200; 
                objects.push(new Grass(rootX + offsetX, rootY));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            drawBackground(); 
            
            // Background Layer (Dimmer)
            ctx.save();
            ctx.globalAlpha = 0.4; // Slightly more transparent for depth
            bgObjects.forEach(obj => {
                obj.update();
                obj.draw(ctx);
            });
            ctx.restore();

            // Foreground Layer
            objects.forEach(obj => {
                obj.update();
                obj.draw(ctx);
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('click', startGarden);
        setTimeout(startGarden, 500);
        animate();

    </script>
</body>
</html>
